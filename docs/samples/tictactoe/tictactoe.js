// Generated by Haxe 3.4.4
(function () { "use strict";
var $estr = function() { return js_Boot.__string_rec(this,''); };
var Main = function() { };
Main.__name__ = true;
Main.main = function() {
	Main.terminal = new Terminal({ cursorBlink : true, cols : 80, rows : 25});
	Main.terminal.open(window.document.body,true);
	var player = minimax_Player.A;
	var board = [[BoardSpace.Empty,BoardSpace.Empty,BoardSpace.Empty],[BoardSpace.Empty,BoardSpace.Empty,BoardSpace.Empty],[BoardSpace.Empty,BoardSpace.Empty,BoardSpace.Empty]];
	Main.drawEmptyBoard();
	var timer = new haxe_Timer(1000);
	timer.run = function() {
		var result = minimax_Minimax.calculate(10,board,player,Mechanics.scoreFunction,Mechanics.getAvailableMoves,Mechanics.calculateNewState);
		if(result.move == null) {
			timer.stop();
			var score = result.score;
			if(score > 0.1) {
				var s = Main.draw(player == minimax_Player.A ? BoardSpace.X : BoardSpace.O) + " won!";
				Main.terminal.writeln(s);
			} else if(score < -0.1) {
				var s1 = Main.draw(player == minimax_Player.A ? BoardSpace.O : BoardSpace.X) + " won!";
				Main.terminal.writeln(s1);
			} else {
				Main.terminal.writeln("It was a draw!");
			}
			return;
		}
		board = Mechanics.calculateNewState(board,result.move);
		switch(player[1]) {
		case 0:
			player = minimax_Player.B;
			break;
		case 1:
			player = minimax_Player.A;
			break;
		}
		Main.drawBoard(board);
	};
};
Main.drawEmptyBoard = function() {
	Main.terminal.writeln("  A   B   C    ");
	Main.terminal.writeln("               ");
	Main.terminal.writeln("    |   |     1");
	Main.terminal.writeln(" ---+---+---   ");
	Main.terminal.writeln("    |   |     2");
	Main.terminal.writeln(" ---+---+---   ");
	Main.terminal.writeln("    |   |     3");
	Main.terminal.writeln("               ");
};
Main.draw = function(s) {
	switch(s[1]) {
	case 0:
		return " ";
	case 1:
		return "\x1B[1;31mX\x1B[0m";
	case 2:
		return "\x1B[1;34mO\x1B[0m";
	}
};
Main.drawBoard = function(board) {
	var up = function(x) {
		return "\x1B[" + x + "A";
	};
	var down = function(x1) {
		return "\x1B[" + x1 + "B";
	};
	var right = function(x2) {
		return "\x1B[" + x2 + "C";
	};
	var left = function(x3) {
		return "\x1B[" + x3 + "D";
	};
	var s = left(1000);
	Main.terminal.write(s);
	var s1 = up(6) + right(2) + Main.draw(board[0][0]);
	Main.terminal.write(s1);
	var s2 = right(3) + Main.draw(board[0][1]);
	Main.terminal.write(s2);
	var s3 = right(3) + Main.draw(board[0][2]);
	Main.terminal.write(s3);
	var s4 = left(1000);
	Main.terminal.write(s4);
	var s5 = down(2) + right(2) + Main.draw(board[1][0]);
	Main.terminal.write(s5);
	var s6 = right(3) + Main.draw(board[1][1]);
	Main.terminal.write(s6);
	var s7 = right(3) + Main.draw(board[1][2]);
	Main.terminal.write(s7);
	var s8 = left(1000);
	Main.terminal.write(s8);
	var s9 = down(2) + right(2) + Main.draw(board[2][0]);
	Main.terminal.write(s9);
	var s10 = right(3) + Main.draw(board[2][1]);
	Main.terminal.write(s10);
	var s11 = right(3) + Main.draw(board[2][2]);
	Main.terminal.write(s11);
	var s12 = left(1000) + down(2);
	Main.terminal.write(s12);
};
Math.__name__ = true;
var BoardSpace = { __ename__ : true, __constructs__ : ["Empty","X","O"] };
BoardSpace.Empty = ["Empty",0];
BoardSpace.Empty.toString = $estr;
BoardSpace.Empty.__enum__ = BoardSpace;
BoardSpace.X = ["X",1];
BoardSpace.X.toString = $estr;
BoardSpace.X.__enum__ = BoardSpace;
BoardSpace.O = ["O",2];
BoardSpace.O.toString = $estr;
BoardSpace.O.__enum__ = BoardSpace;
var Mechanics = function() { };
Mechanics.__name__ = true;
Mechanics.scoreFunction = function(state,player) {
	var thisPlayer;
	switch(player[1]) {
	case 0:
		thisPlayer = BoardSpace.X;
		break;
	case 1:
		thisPlayer = BoardSpace.O;
		break;
	}
	var otherPlayer;
	switch(player[1]) {
	case 0:
		otherPlayer = BoardSpace.O;
		break;
	case 1:
		otherPlayer = BoardSpace.X;
		break;
	}
	var _g = 0;
	while(_g < 3) {
		var i = _g++;
		if(state[i][0] == thisPlayer && state[i][1] == thisPlayer && state[i][2] == thisPlayer) {
			return Infinity;
		} else if(state[i][0] == otherPlayer && state[i][1] == otherPlayer && state[i][2] == otherPlayer) {
			return -Infinity;
		}
		if(state[0][i] == thisPlayer && state[1][i] == thisPlayer && state[2][i] == thisPlayer) {
			return Infinity;
		}
		if(state[0][i] == otherPlayer && state[1][i] == otherPlayer && state[2][i] == otherPlayer) {
			return -Infinity;
		}
	}
	if(state[0][0] == thisPlayer && state[1][1] == thisPlayer && state[2][2] == thisPlayer) {
		return Infinity;
	} else if(state[0][0] == otherPlayer && state[1][1] == otherPlayer && state[2][2] == otherPlayer) {
		return -Infinity;
	}
	if(state[0][2] == thisPlayer && state[1][1] == thisPlayer && state[2][0] == thisPlayer) {
		return Infinity;
	} else if(state[0][2] == otherPlayer && state[1][1] == otherPlayer && state[2][0] == otherPlayer) {
		return -Infinity;
	}
	var numAlmosts = 0;
	var _g1 = 0;
	while(_g1 < 3) {
		var j = _g1++;
		var numX = 0;
		var numEmpty = 0;
		var numO = 0;
		var _g11 = 0;
		while(_g11 < 3) {
			var i1 = _g11++;
			var _g2 = state[j][i1];
			switch(_g2[1]) {
			case 0:
				++numEmpty;
				break;
			case 1:
				++numX;
				break;
			case 2:
				++numO;
				break;
			}
		}
		if(thisPlayer == BoardSpace.X && numX == 2 && numEmpty == 1) {
			++numAlmosts;
		} else if(thisPlayer == BoardSpace.X && numO == 2 && numEmpty == 1) {
			--numAlmosts;
		} else if(thisPlayer == BoardSpace.O && numO == 2 && numEmpty == 1) {
			++numAlmosts;
		} else if(thisPlayer == BoardSpace.O && numX == 2 && numEmpty == 1) {
			--numAlmosts;
		}
		numX = 0;
		numEmpty = 0;
		numO = 0;
		var _g12 = 0;
		while(_g12 < 3) {
			var i2 = _g12++;
			var _g21 = state[i2][j];
			switch(_g21[1]) {
			case 0:
				++numEmpty;
				break;
			case 1:
				++numX;
				break;
			case 2:
				++numO;
				break;
			}
		}
		if(thisPlayer == BoardSpace.X && numX == 2 && numEmpty == 1) {
			++numAlmosts;
		} else if(thisPlayer == BoardSpace.X && numO == 2 && numEmpty == 1) {
			--numAlmosts;
		} else if(thisPlayer == BoardSpace.O && numO == 2 && numEmpty == 1) {
			++numAlmosts;
		} else if(thisPlayer == BoardSpace.O && numX == 2 && numEmpty == 1) {
			--numAlmosts;
		}
	}
	return numAlmosts;
};
Mechanics.getAvailableMoves = function(state,player) {
	var moves = [];
	var _g = 0;
	while(_g < 3) {
		var y = _g++;
		var _g1 = 0;
		while(_g1 < 3) {
			var x = _g1++;
			if(state[y][x] == BoardSpace.Empty) {
				moves.push({ x : x, y : y, player : player});
			}
		}
	}
	return moves;
};
Mechanics.calculateNewState = function(oldState,move) {
	var _g = [];
	var _g1 = 0;
	while(_g1 < 3) {
		var y = _g1++;
		var _g2 = [];
		var _g3 = 0;
		while(_g3 < 3) {
			var x = _g3++;
			_g2.push(oldState[y][x]);
		}
		_g.push(_g2);
	}
	var newState = _g;
	var newState1 = newState[move.y];
	var _g11 = move.player;
	var tmp;
	switch(_g11[1]) {
	case 0:
		tmp = BoardSpace.X;
		break;
	case 1:
		tmp = BoardSpace.O;
		break;
	}
	newState1[move.x] = tmp;
	return newState;
};
var haxe_Timer = function(time_ms) {
	var me = this;
	this.id = setInterval(function() {
		me.run();
	},time_ms);
};
haxe_Timer.__name__ = true;
haxe_Timer.prototype = {
	stop: function() {
		if(this.id == null) {
			return;
		}
		clearInterval(this.id);
		this.id = null;
	}
	,run: function() {
	}
};
var js_Boot = function() { };
js_Boot.__name__ = true;
js_Boot.__string_rec = function(o,s) {
	if(o == null) {
		return "null";
	}
	if(s.length >= 5) {
		return "<...>";
	}
	var t = typeof(o);
	if(t == "function" && (o.__name__ || o.__ename__)) {
		t = "object";
	}
	switch(t) {
	case "function":
		return "<function>";
	case "object":
		if(o instanceof Array) {
			if(o.__enum__) {
				if(o.length == 2) {
					return o[0];
				}
				var str = o[0] + "(";
				s += "\t";
				var _g1 = 2;
				var _g = o.length;
				while(_g1 < _g) {
					var i = _g1++;
					if(i != 2) {
						str += "," + js_Boot.__string_rec(o[i],s);
					} else {
						str += js_Boot.__string_rec(o[i],s);
					}
				}
				return str + ")";
			}
			var l = o.length;
			var i1;
			var str1 = "[";
			s += "\t";
			var _g11 = 0;
			var _g2 = l;
			while(_g11 < _g2) {
				var i2 = _g11++;
				str1 += (i2 > 0 ? "," : "") + js_Boot.__string_rec(o[i2],s);
			}
			str1 += "]";
			return str1;
		}
		var tostr;
		try {
			tostr = o.toString;
		} catch( e ) {
			return "???";
		}
		if(tostr != null && tostr != Object.toString && typeof(tostr) == "function") {
			var s2 = o.toString();
			if(s2 != "[object Object]") {
				return s2;
			}
		}
		var k = null;
		var str2 = "{\n";
		s += "\t";
		var hasp = o.hasOwnProperty != null;
		for( var k in o ) {
		if(hasp && !o.hasOwnProperty(k)) {
			continue;
		}
		if(k == "prototype" || k == "__class__" || k == "__super__" || k == "__interfaces__" || k == "__properties__") {
			continue;
		}
		if(str2.length != 2) {
			str2 += ", \n";
		}
		str2 += s + k + " : " + js_Boot.__string_rec(o[k],s);
		}
		s = s.substring(1);
		str2 += "\n" + s + "}";
		return str2;
	case "string":
		return o;
	default:
		return String(o);
	}
};
var minimax_Minimax = function() { };
minimax_Minimax.__name__ = true;
minimax_Minimax.calculate = function(depth,state,player,score,moves,newState) {
	var currentScore = score(state,player);
	if(depth == 0 || currentScore == Infinity || currentScore == -Infinity) {
		return { move : null, score : currentScore};
	}
	var possibleMoves = moves(state,player);
	if(possibleMoves.length == 0) {
		return { move : null, score : score(state,player)};
	}
	var otherPlayer;
	switch(player[1]) {
	case 0:
		otherPlayer = minimax_Player.B;
		break;
	case 1:
		otherPlayer = minimax_Player.A;
		break;
	}
	var scores = [];
	var _g = 0;
	while(_g < possibleMoves.length) {
		var move = possibleMoves[_g];
		++_g;
		var resultantState = newState(state,move);
		var result = minimax_Minimax.calculate(depth - 1,resultantState,otherPlayer,score,moves,newState);
		scores.push(-1 * result.score);
	}
	var bestMove = null;
	var bestScore = 0;
	var _g1 = 0;
	var _g2 = possibleMoves.length;
	while(_g1 < _g2) {
		var i = _g1++;
		if(bestMove == null || scores[i] > bestScore) {
			bestMove = possibleMoves[i];
			bestScore = scores[i];
		}
	}
	return { move : bestMove, score : bestScore};
};
var minimax_Player = { __ename__ : true, __constructs__ : ["A","B"] };
minimax_Player.A = ["A",0];
minimax_Player.A.toString = $estr;
minimax_Player.A.__enum__ = minimax_Player;
minimax_Player.B = ["B",1];
minimax_Player.B.toString = $estr;
minimax_Player.B.__enum__ = minimax_Player;
String.__name__ = true;
Array.__name__ = true;
Main.main();
})();
